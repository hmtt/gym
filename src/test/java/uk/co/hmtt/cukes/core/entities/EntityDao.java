package uk.co.hmtt.cukes.core.entities;

import org.apache.commons.collections.Predicate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.jdbc.support.rowset.SqlRowSet;
import org.springframework.stereotype.Component;
import org.springframework.test.util.ReflectionTestUtils;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.ReflectionUtils;
import uk.co.hmtt.cukes.core.annotations.AutoGenerated;
import uk.co.hmtt.cukes.core.annotations.Bind;
import uk.co.hmtt.cukes.core.annotations.Unique;
import uk.co.hmtt.gym.app.exceptions.GymException;

import java.lang.reflect.Field;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static java.lang.String.format;
import static org.apache.commons.collections.CollectionUtils.filter;
import static org.apache.commons.collections.CollectionUtils.select;
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.core.Is.is;
import static uk.co.hmtt.gym.app.utilities.CollectionsUtil.safeIterator;

@Component
public class EntityDao {

    private String siteName = "booker";

    private final static Logger LOGGER = LoggerFactory.getLogger(EntityDao.class);
    public static final String RECORD_OF_ENTITY_DOES_NOT_ALREADY_EXIST = "Record of entity {} does not already exist";
    public static final String WHERE = " WHERE ";
    public static final String AND = " AND ";

    public final String SELECT_FROM_GYM = "SELECT * FROM " + siteName + ".";
    public final String DELETE_FROM_GYM = "delete from " + siteName + ".";

    @Autowired
    private JdbcTemplate jdbcTemplate;

    public enum TABLE_NAME {USER_ACTIVITY, USER, EXCLUSION, ACTIVITY}

    private Map<Class<?>, TABLE_NAME> entityTranslation = new HashMap<>();

    {
        entityTranslation.put(User.class, TABLE_NAME.USER);
        entityTranslation.put(ActivityEntity.class, TABLE_NAME.ACTIVITY);
        entityTranslation.put(UserActivityEntity.class, TABLE_NAME.USER_ACTIVITY);
        entityTranslation.put(ExclusionEntity.class, TABLE_NAME.EXCLUSION);
    }

    @Transactional
    public <T> void insert(Class<T> clz, List<T> objs) {
        for (T obj : objs) {
            add(clz, obj);
        }
    }

    @Transactional
    public void wipe() {
        for (TABLE_NAME table : TABLE_NAME.values()) {
            jdbcTemplate.update(DELETE_FROM_GYM + table.name());
        }
    }

    public User getUser(final String email) {
        final List<User> users = fetch(User.class);
        final List<UserActivityEntity> userActivityEntities = fetch(UserActivityEntity.class);
        final List<ActivityEntity> activityEntities = fetch(ActivityEntity.class);
        final List<ExclusionEntity> exclusionEntities = fetch(ExclusionEntity.class);

        filter(users, byEmailAddress(email));
        assertThat(format("Expected one user to be found for email address: %s", email), users.size(), is(equalTo(1)));

        final User user = users.get(0);

        final List<Integer> userActivityIds = deriveListOfScheduledActivityIds(user, userActivityEntities);
        final List<ActivityEntity> scheduledActivityEntities = new ArrayList<>();
        select(activityEntities, forSpecifiedUser(userActivityIds), scheduledActivityEntities);
        user.setScheduledActivitiesActivities(scheduledActivityEntities);

        final List<Integer> userActivityBookedIds = deriveListOfBookedActivityIds(user, userActivityEntities);
        final List<ActivityEntity> bookedActivityEntities = new ArrayList<>();
        select(activityEntities, forSpecifiedUser(userActivityBookedIds), bookedActivityEntities);
        user.setBookedActivities(bookedActivityEntities);

        for (ActivityEntity activityEntity : safeIterator(activityEntities)) {
            for (ExclusionEntity exclusionEntity : safeIterator(exclusionEntities)) {
                if (exclusionEntity.getUserActivity_activityId() == activityEntity.getId() && exclusionEntity.getUserActivity_userId() == user.getId()) {
                    activityEntity.getExclusions().add(exclusionEntity);
                }
            }
        }

        return user;

    }

    private List<Integer> deriveListOfBookedActivityIds(User user, List<UserActivityEntity> userActivityEntities) {
        filter(userActivityEntities, byUserBookedActivities(user));

        final List<Integer> userActivityIds = new ArrayList<>();
        for (UserActivityEntity entities : userActivityEntities) {
            if (entities.getLastBooked() != null) {
                userActivityIds.add(entities.getActivityId());
            }
        }
        return userActivityIds;
    }

    private List<Integer> deriveListOfScheduledActivityIds(User user, List<UserActivityEntity> userActivityEntities) {
        filter(userActivityEntities, byUserBookedActivities(user));

        final List<Integer> userActivityIds = new ArrayList<>();
        for (UserActivityEntity entities : userActivityEntities) {
            userActivityIds.add(entities.getActivityId());
        }
        return userActivityIds;
    }

    private Predicate forSpecifiedUser(final List<Integer> userActivityIds) {
        return new Predicate() {
            @Override
            public boolean evaluate(Object object) {
                final ActivityEntity entities = (ActivityEntity) object;
                return userActivityIds.contains(entities.getId());
            }
        };
    }

    private Predicate byUserBookedActivities(final User user) {
        return new Predicate() {
            @Override
            public boolean evaluate(Object object) {
                final UserActivityEntity userActivityEntity = (UserActivityEntity) object;
                return userActivityEntity.getUserId() == user.getId();
            }
        };
    }

    private Predicate byEmailAddress(final String email) {
        return new Predicate() {
            @Override
            public boolean evaluate(Object object) {
                final User user = (User) object;
                return user.getEmail().equals(email);
            }
        };
    }

    public SqlRowSet fetchTable(TABLE_NAME tableName) {
        return jdbcTemplate.queryForRowSet(SELECT_FROM_GYM + tableName.name());
    }

    public <T extends Entity<T>> List<T> fetch(Class<T> clz) {
        final Entity<T> entity = createInstance(clz);
        return jdbcTemplate.query(SELECT_FROM_GYM + entity.getTableName(), new RowMapper<T>() {
            @Override
            public T mapRow(ResultSet resultSet, int i) throws SQLException {
                return entity.mapRow(resultSet, i);
            }
        });
    }

    private <T> T createInstance(Class<T> clz) {
        try {
            return clz.newInstance();
        } catch (InstantiationException | IllegalAccessException e) {
            throw new GymException(e);
        }
    }

    private <T> void add(Class<T> clz, Object data) {

        final T existingRow = rowAlreadyExists(clz, data);
        if (existingRow == null) {
            LOGGER.debug(RECORD_OF_ENTITY_DOES_NOT_ALREADY_EXIST, clz);
            addRecord(clz, data);
        } else {
            for (Field declaredField : data.getClass().getDeclaredFields()) {
                if (declaredField.isAnnotationPresent(AutoGenerated.class) || declaredField.isAnnotationPresent(Unique.class)) {
                    declaredField.setAccessible(true);
                    ReflectionTestUtils.setField(data, declaredField.getName(), ReflectionUtils.getField(declaredField, existingRow));
                }
            }
        }

    }

    private <T> void addRecord(Class<T> clz, Object data) {
        final Map<String, Object> parameters = new HashMap<>();
        Field id = null;
        for (Field declaredField : data.getClass().getDeclaredFields()) {
            declaredField.setAccessible(true);
            if (declaredField.isAnnotationPresent(Bind.class)) {
                parameters.put(declaredField.getName(), ReflectionUtils.getField(declaredField, data));
            } else if (declaredField.isAnnotationPresent(AutoGenerated.class)) {
                id = declaredField;
            }
        }

        if (id != null) {
            SimpleJdbcInsert insert = new SimpleJdbcInsert(this.jdbcTemplate).withSchemaName(siteName).withTableName(entityTranslation.get(clz).toString()).usingGeneratedKeyColumns(id.getName());
            final Number number = insert.executeAndReturnKey(parameters);
            ReflectionUtils.setField(id, data, number.intValue());
        } else {
            SimpleJdbcInsert insert = new SimpleJdbcInsert(this.jdbcTemplate).withSchemaName(siteName).withTableName(entityTranslation.get(clz).toString());
            insert.execute(parameters);
        }
    }

    private <T> T rowAlreadyExists(Class<T> clz, Object data) {
        try {
            String sql = SELECT_FROM_GYM + entityTranslation.get(clz) + WHERE;

            final List<Object> uniqueIdentifiers = new ArrayList<>();
            for (Field declaredField : data.getClass().getDeclaredFields()) {
                declaredField.setAccessible(true);
                if (declaredField.isAnnotationPresent(Unique.class)) {
                    if (uniqueIdentifiers.isEmpty()) {
                        sql += declaredField.getName() + " = ?";
                    } else {
                        sql += AND + declaredField.getName() + " = ?";
                    }
                    uniqueIdentifiers.add(ReflectionUtils.getField(declaredField, data));
                }
            }

            return jdbcTemplate.queryForObject(
                    sql, uniqueIdentifiers.toArray(),
                    new BeanPropertyRowMapper<>(clz));

        } catch (EmptyResultDataAccessException e) {
            return null;
        }
    }

}

